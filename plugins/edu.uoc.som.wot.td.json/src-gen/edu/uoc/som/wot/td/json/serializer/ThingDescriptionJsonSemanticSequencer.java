/*
 * generated by Xtext 2.17.0
 */
package edu.uoc.som.wot.td.json.serializer;

import com.google.inject.Inject;
import edu.uoc.som.wot.td.json.services.ThingDescriptionJsonGrammarAccess;
import edu.uoc.som.wot.td.json.thingDescriptionJson.JsonActionAffordance;
import edu.uoc.som.wot.td.json.thingDescriptionJson.JsonDataSchema;
import edu.uoc.som.wot.td.json.thingDescriptionJson.JsonEventAffordance;
import edu.uoc.som.wot.td.json.thingDescriptionJson.JsonExpectedResponse;
import edu.uoc.som.wot.td.json.thingDescriptionJson.JsonForm;
import edu.uoc.som.wot.td.json.thingDescriptionJson.JsonLink;
import edu.uoc.som.wot.td.json.thingDescriptionJson.JsonMultiLanguageEntry;
import edu.uoc.som.wot.td.json.thingDescriptionJson.JsonPropertyAffordance;
import edu.uoc.som.wot.td.json.thingDescriptionJson.JsonSecurityScheme;
import edu.uoc.som.wot.td.json.thingDescriptionJson.JsonThing;
import edu.uoc.som.wot.td.json.thingDescriptionJson.JsonVersionInfo;
import edu.uoc.som.wot.td.json.thingDescriptionJson.ThingDescriptionJsonPackage;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ThingDescriptionJsonSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ThingDescriptionJsonGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ThingDescriptionJsonPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ThingDescriptionJsonPackage.JSON_ACTION_AFFORDANCE:
				sequence_JsonActionAffordance(context, (JsonActionAffordance) semanticObject); 
				return; 
			case ThingDescriptionJsonPackage.JSON_DATA_SCHEMA:
				sequence_JsonDataSchema(context, (JsonDataSchema) semanticObject); 
				return; 
			case ThingDescriptionJsonPackage.JSON_EVENT_AFFORDANCE:
				sequence_JsonEventAffordance(context, (JsonEventAffordance) semanticObject); 
				return; 
			case ThingDescriptionJsonPackage.JSON_EXPECTED_RESPONSE:
				sequence_JsonExpectedResponse(context, (JsonExpectedResponse) semanticObject); 
				return; 
			case ThingDescriptionJsonPackage.JSON_FORM:
				sequence_JsonForm(context, (JsonForm) semanticObject); 
				return; 
			case ThingDescriptionJsonPackage.JSON_LINK:
				sequence_JsonLink(context, (JsonLink) semanticObject); 
				return; 
			case ThingDescriptionJsonPackage.JSON_MULTI_LANGUAGE_ENTRY:
				sequence_JsonMultiLanguageEntry(context, (JsonMultiLanguageEntry) semanticObject); 
				return; 
			case ThingDescriptionJsonPackage.JSON_PROPERTY_AFFORDANCE:
				sequence_JsonPropertyAffordance(context, (JsonPropertyAffordance) semanticObject); 
				return; 
			case ThingDescriptionJsonPackage.JSON_SECURITY_SCHEME:
				sequence_JsonSecurityScheme(context, (JsonSecurityScheme) semanticObject); 
				return; 
			case ThingDescriptionJsonPackage.JSON_THING:
				sequence_JsonThing(context, (JsonThing) semanticObject); 
				return; 
			case ThingDescriptionJsonPackage.JSON_VERSION_INFO:
				sequence_JsonVersionInfo(context, (JsonVersionInfo) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     JsonActionAffordance returns JsonActionAffordance
	 *
	 * Constraint:
	 *     (
	 *         id=AnyString 
	 *         (
	 *             (
	 *                 safe=JsonBoolean | 
	 *                 idempotent=JsonBoolean | 
	 *                 input=JsonDataSchema | 
	 *                 output=JsonDataSchema | 
	 *                 ld_type+=AnyString | 
	 *                 title=AnyString | 
	 *                 description=AnyString
	 *             )? 
	 *             (ld_type+=AnyString ld_type+=AnyString*)? 
	 *             (forms+=JsonForm forms+=JsonForm*)? 
	 *             (titles+=JsonMultiLanguageEntry titles+=JsonMultiLanguageEntry*)? 
	 *             (descriptions+=JsonMultiLanguageEntry descriptions+=JsonMultiLanguageEntry*)? 
	 *             (uriVariable+=JsonDataSchema uriVariable+=JsonDataSchema*)?
	 *         )+
	 *     )
	 */
	protected void sequence_JsonActionAffordance(ISerializationContext context, JsonActionAffordance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JsonDataSchema returns JsonDataSchema
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             ld_type+=AnyString | 
	 *             title=AnyString | 
	 *             description=AnyString | 
	 *             type=JsonType | 
	 *             const=AnyString | 
	 *             unit=AnyString | 
	 *             readOnly=JsonBoolean | 
	 *             writeOnly=JsonBoolean | 
	 *             format=AnyString | 
	 *             minItems=INT | 
	 *             maxItems=INT | 
	 *             minimum=INT | 
	 *             maximum=INT
	 *         )? 
	 *         (ld_type+=AnyString ld_type+=AnyString*)? 
	 *         (enum+=AnyString enum+=AnyString*)? 
	 *         (oneOf+=JsonDataSchema oneOf+=JsonDataSchema*)? 
	 *         (titles+=JsonMultiLanguageEntry titles+=JsonMultiLanguageEntry*)? 
	 *         (descriptions+=JsonMultiLanguageEntry descriptions+=JsonMultiLanguageEntry*)? 
	 *         (items+=JsonDataSchema items+=JsonDataSchema*)? 
	 *         (required+=AnyString required+=AnyString*)? 
	 *         (properties+=JsonDataSchema properties+=JsonDataSchema*)?
	 *     )+
	 */
	protected void sequence_JsonDataSchema(ISerializationContext context, JsonDataSchema semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JsonEventAffordance returns JsonEventAffordance
	 *
	 * Constraint:
	 *     (
	 *         id=AnyString 
	 *         (
	 *             (
	 *                 data=JsonDataSchema | 
	 *                 subscription=JsonDataSchema | 
	 *                 cancellation=JsonDataSchema | 
	 *                 ld_type+=AnyString | 
	 *                 title=AnyString | 
	 *                 description=AnyString
	 *             )? 
	 *             (ld_type+=AnyString ld_type+=AnyString*)? 
	 *             (forms+=JsonForm forms+=JsonForm*)? 
	 *             (titles+=JsonMultiLanguageEntry titles+=JsonMultiLanguageEntry*)? 
	 *             (descriptions+=JsonMultiLanguageEntry descriptions+=JsonMultiLanguageEntry*)? 
	 *             (uriVariable+=JsonDataSchema uriVariable+=JsonDataSchema*)?
	 *         )+
	 *     )
	 */
	protected void sequence_JsonEventAffordance(ISerializationContext context, JsonEventAffordance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JsonExpectedResponse returns JsonExpectedResponse
	 *
	 * Constraint:
	 *     contentType=AnyString
	 */
	protected void sequence_JsonExpectedResponse(ISerializationContext context, JsonExpectedResponse semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ThingDescriptionJsonPackage.Literals.JSON_EXPECTED_RESPONSE__CONTENT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ThingDescriptionJsonPackage.Literals.JSON_EXPECTED_RESPONSE__CONTENT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJsonExpectedResponseAccess().getContentTypeAnyStringParserRuleCall_4_0(), semanticObject.getContentType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     JsonForm returns JsonForm
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             ld_type+=AnyString | 
	 *             op+=AnyString | 
	 *             _href=AnyString | 
	 *             contentType=AnyString | 
	 *             contentCoding=AnyString | 
	 *             subprotocol=AnyString | 
	 *             security+=AnyString | 
	 *             scopes+=AnyString | 
	 *             response=JsonExpectedResponse
	 *         )? 
	 *         (ld_type+=AnyString ld_type+=AnyString*)? 
	 *         (op+=AnyString op+=AnyString*)? 
	 *         (security+=AnyString security+=AnyString*)? 
	 *         (scopes+=AnyString scopes+=AnyString*)?
	 *     )+
	 */
	protected void sequence_JsonForm(ISerializationContext context, JsonForm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JsonLink returns JsonLink
	 *
	 * Constraint:
	 *     (_href=AnyString | type=AnyString | rel=AnyString | anchor=AnyString)*
	 */
	protected void sequence_JsonLink(ISerializationContext context, JsonLink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JsonMultiLanguageEntry returns JsonMultiLanguageEntry
	 *
	 * Constraint:
	 *     (language=AnyString content=AnyString)
	 */
	protected void sequence_JsonMultiLanguageEntry(ISerializationContext context, JsonMultiLanguageEntry semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ThingDescriptionJsonPackage.Literals.JSON_MULTI_LANGUAGE_ENTRY__LANGUAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ThingDescriptionJsonPackage.Literals.JSON_MULTI_LANGUAGE_ENTRY__LANGUAGE));
			if (transientValues.isValueTransient(semanticObject, ThingDescriptionJsonPackage.Literals.JSON_MULTI_LANGUAGE_ENTRY__CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ThingDescriptionJsonPackage.Literals.JSON_MULTI_LANGUAGE_ENTRY__CONTENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJsonMultiLanguageEntryAccess().getLanguageAnyStringParserRuleCall_1_0(), semanticObject.getLanguage());
		feeder.accept(grammarAccess.getJsonMultiLanguageEntryAccess().getContentAnyStringParserRuleCall_3_0(), semanticObject.getContent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     JsonPropertyAffordance returns JsonPropertyAffordance
	 *
	 * Constraint:
	 *     (
	 *         id=AnyString 
	 *         (
	 *             (
	 *                 observable=JsonBoolean | 
	 *                 ld_type+=AnyString | 
	 *                 title=AnyString | 
	 *                 description=AnyString | 
	 *                 type=JsonType | 
	 *                 const=AnyString | 
	 *                 unit=AnyString | 
	 *                 readOnly=JsonBoolean | 
	 *                 writeOnly=JsonBoolean | 
	 *                 format=AnyString
	 *             )? 
	 *             (ld_type+=AnyString ld_type+=AnyString*)? 
	 *             (titles+=JsonMultiLanguageEntry titles+=JsonMultiLanguageEntry*)? 
	 *             (descriptions+=JsonMultiLanguageEntry descriptions+=JsonMultiLanguageEntry*)? 
	 *             (forms+=JsonForm forms+=JsonForm*)? 
	 *             (uriVariable+=JsonDataSchema uriVariable+=JsonDataSchema*)? 
	 *             (enum+=AnyString enum+=AnyString*)? 
	 *             (oneOf+=JsonDataSchema oneOf+=JsonDataSchema*)?
	 *         )+
	 *     )
	 */
	protected void sequence_JsonPropertyAffordance(ISerializationContext context, JsonPropertyAffordance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JsonSecurityScheme returns JsonSecurityScheme
	 *
	 * Constraint:
	 *     id=AnyString
	 */
	protected void sequence_JsonSecurityScheme(ISerializationContext context, JsonSecurityScheme semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ThingDescriptionJsonPackage.Literals.JSON_SECURITY_SCHEME__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ThingDescriptionJsonPackage.Literals.JSON_SECURITY_SCHEME__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJsonSecuritySchemeAccess().getIdAnyStringParserRuleCall_1_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     JsonThing returns JsonThing
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             ld_context+=AnyString | 
	 *             ld_context+=AnyString | 
	 *             ld_context+=AnyString | 
	 *             ld_type+=AnyString | 
	 *             id=AnyString | 
	 *             title=AnyString | 
	 *             description=AnyString | 
	 *             created=AnyString | 
	 *             modified=AnyString | 
	 *             support=AnyString | 
	 *             base=AnyString | 
	 *             security+=AnyString | 
	 *             version=JsonVersionInfo
	 *         )? 
	 *         (ld_type+=AnyString ld_type+=AnyString*)? 
	 *         (security+=AnyString security+=AnyString*)? 
	 *         (forms+=JsonForm forms+=JsonForm*)? 
	 *         (links+=JsonLink links+=JsonLink*)? 
	 *         (titles+=JsonMultiLanguageEntry titles+=JsonMultiLanguageEntry*)? 
	 *         (descriptions+=JsonMultiLanguageEntry descriptions+=JsonMultiLanguageEntry*)? 
	 *         (properties+=JsonPropertyAffordance properties+=JsonPropertyAffordance*)? 
	 *         (actions+=JsonActionAffordance actions+=JsonActionAffordance*)? 
	 *         (events+=JsonEventAffordance events+=JsonEventAffordance*)? 
	 *         (securityDefinitions+=JsonSecurityScheme securityDefinitions+=JsonSecurityScheme*)?
	 *     )+
	 */
	protected void sequence_JsonThing(ISerializationContext context, JsonThing semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JsonVersionInfo returns JsonVersionInfo
	 *
	 * Constraint:
	 *     instance=AnyString
	 */
	protected void sequence_JsonVersionInfo(ISerializationContext context, JsonVersionInfo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ThingDescriptionJsonPackage.Literals.JSON_VERSION_INFO__INSTANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ThingDescriptionJsonPackage.Literals.JSON_VERSION_INFO__INSTANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJsonVersionInfoAccess().getInstanceAnyStringParserRuleCall_4_0(), semanticObject.getInstance());
		feeder.finish();
	}
	
	
}
